Sections:
00: "org0001:8003" (8003-8274)


Source: "programs/assembler.asm"
                        	     1:   .org $8003
                        	     2: 
                        	     3: ; memory map:
                        	     4: SERIAL   = $8002
                        	     5: EXIT_VEC = $fff8
                        	     6: 
                        	     7: ; ascii codes:
                        	     8: NEWLINE   = $0a
                        	     9: ESCAPE    = $1b
                        	    10: DELETE    = $7f
                        	    11: BACKSPACE = $08
                        	    12: 
                        	    13: ; memory allocation:
                        	    14: BYTE_BUILD  = $40     ; 1 byte
                        	    15: PRINT       = $50     ;  1byte
                        	    16: opc_buf     = $20     ; 3 bytes 
                        	    17: opc_handler = $23     ; 2 bytes
                        	    18: insert_ptr  = $30     ; 2 bytes (matches the monitor)
                        	    19: input_buf   = $0200   ; 256 bytes
                        	    20: input_ptr   = $10     ; 1 bytes
                        	    21: 
                        	    22: main:
00:8003 A9A6            	    23:   lda #start_msg
00:8005 8550            	    24:   sta PRINT
00:8007 A981            	    25:   lda #>start_msg
00:8009 8551            	    26:   sta PRINT + 1
00:800B 209481          	    27:   jsr print
                        	    28: 
                        	    29: mainloop:
00:800E A90A            	    30:   lda #NEWLINE
00:8010 8D0280          	    31:   sta SERIAL
00:8013 208980          	    32:   jsr print_addr
00:8016 20ED80          	    33:   jsr get_line
00:8019 203781          	    34:   jsr get_key
00:801C 8520            	    35:   sta opc_buf
00:801E 203781          	    36:   jsr get_key
00:8021 8521            	    37:   sta opc_buf+1
00:8023 203781          	    38:   jsr get_key
00:8026 8522            	    39:   sta opc_buf+2
                        	    40: 
00:8028 A200            	    41:   ldx #0            ; start checking at the first opcode in the table
                        	    42: dispatch_loop:
00:802A 20AA80          	    43:   jsr dispatch      ; run the opcode handler if it matches and move on
00:802D C001            	    44:   cpy #1            ; if a match was not found,
00:802F D0F9            	    45:   bne dispatch_loop ; keep going.
00:8031 E0F9            	    46:   cpx #249          ; if the table is exhausted,
00:8033 B003            	    47:   bcs _dispatch_loop_fail   ; the opcode is unknown. 
00:8035 4C0E80          	    48:   jmp mainloop      ; otherwise, read the next opcode
                        	    49: _dispatch_loop_fail:
00:8038 4CDF80          	    50:   jmp bad_handler
                        	    51: 
                        	    52: ; increment the insertion pointer
                        	    53: inc_insert:
00:803B E630            	    54:   inc insert_ptr
00:803D D002            	    55:   bne _inc_insert_done
00:803F E631            	    56:   inc insert_ptr+1
                        	    57: _inc_insert_done:
00:8041 60              	    58:   rts
                        	    59: 
                        	    60: ; insert the a register and move on
                        	    61: insert_a:
00:8042 A000            	    62:   ldy #0
00:8044 9130            	    63:   sta (insert_ptr),y
00:8046 203B80          	    64:   jsr inc_insert
00:8049 60              	    65:   rts
                        	    66: 
                        	    67: ; insert the x and a registers and move on
                        	    68: insert_ax:
00:804A A000            	    69:   ldy #0
00:804C 48              	    70:   pha
00:804D 8A              	    71:   txa
00:804E 9130            	    72:   sta (insert_ptr),y
00:8050 203B80          	    73:   jsr inc_insert
00:8053 68              	    74:   pla
00:8054 9130            	    75:   sta (insert_ptr),y
00:8056 203B80          	    76:   jsr inc_insert
00:8059 60              	    77:   rts
                        	    78: 
                        	    79: ; get a value in hex, and return it in A (TODO: support binary (%) and decimal)
                        	    80: get_val:
00:805A 203781          	    81:   jsr get_key
00:805D C924            	    82:   cmp #"$"
00:805F D004            	    83:   bne _get_val_not_hex
00:8061 208581          	    84:   jsr get_byte
00:8064 60              	    85:   rts
                        	    86: _get_val_not_hex:
                        	    87: 
00:8065 C922            	    88:   cmp #$22 ; double quote
00:8067 D009            	    89:   bne _get_val_not_char
00:8069 203781          	    90:   jsr get_key
00:806C 48              	    91:   pha
00:806D 203781          	    92:   jsr get_key
00:8070 68              	    93:   pla
00:8071 60              	    94:   rts
                        	    95: 
                        	    96: _get_val_not_char:
00:8072 4CDF80          	    97:   jmp bad_handler
                        	    98: 
                        	    99: ; get a word in hex and return it in a and x
                        	   100: get_word:
00:8075 203781          	   101:   jsr get_key
00:8078 C924            	   102:   cmp #"$"
00:807A D00A            	   103:   bne _get_word_fail
00:807C 208581          	   104:   jsr get_byte
00:807F 48              	   105:   pha
00:8080 208581          	   106:   jsr get_byte
00:8083 AA              	   107:   tax
00:8084 68              	   108:   pla
00:8085 60              	   109:   rts
                        	   110: _get_word_fail:
00:8086 4CDF80          	   111:   jmp bad_handler
                        	   112: 
                        	   113: ; print the insertion pointer
                        	   114: print_addr:
00:8089 A531            	   115:   lda insert_ptr+1
00:808B 207481          	   116:   jsr hex_byte
00:808E 8E0280          	   117:   stx SERIAL
00:8091 8C0280          	   118:   sty SERIAL
00:8094 A530            	   119:   lda insert_ptr
00:8096 207481          	   120:   jsr hex_byte
00:8099 8E0280          	   121:   stx SERIAL
00:809C 8C0280          	   122:   sty SERIAL
00:809F A93A            	   123:   lda #":"
00:80A1 8D0280          	   124:   sta SERIAL
00:80A4 A920            	   125:   lda #" "
00:80A6 8D0280          	   126:   sta SERIAL
00:80A9 60              	   127:   rts
                        	   128: 
                        	   129: ; 1. match the xth element in the opcode table with the input buffer
                        	   130: ; 2. if it matches, call the opcode handler
                        	   131: ; 3. increment x by 5
                        	   132: ; 4. return in y 1 if the opcode matched, otherwise 0
                        	   133: dispatch:
00:80AA BD5682          	   134:   lda opcode_table,x
00:80AD C520            	   135:   cmp opc_buf
00:80AF D026            	   136:   bne _dispatch_miss_1
00:80B1 E8              	   137:   inx
00:80B2 BD5682          	   138:   lda opcode_table,x
00:80B5 C521            	   139:   cmp opc_buf+1
00:80B7 D01D            	   140:   bne _dispatch_miss_2
00:80B9 E8              	   141:   inx
00:80BA BD5682          	   142:   lda opcode_table,x
00:80BD C522            	   143:   cmp opc_buf+2
00:80BF D014            	   144:   bne _dispatch_miss_3
00:80C1 E8              	   145:   inx
                        	   146: 
00:80C2 BD5682          	   147:   lda opcode_table,x
00:80C5 8523            	   148:   sta opc_handler
00:80C7 BD5782          	   149:   lda opcode_table+1,x
00:80CA 8524            	   150:   sta opc_handler+1
                        	   151: 
                        	   152:   ; there is no indirect jsr, so we do this
00:80CC 20D280          	   153:   jsr _dispatch_run
00:80CF A001            	   154:   ldy #1
00:80D1 60              	   155:   rts
                        	   156: _dispatch_run:
00:80D2 6C2300          	   157:   jmp (opc_handler)
                        	   158: 
                        	   159: _dispatch_miss_3:
00:80D5 CA              	   160:   dex
                        	   161: _dispatch_miss_2:
00:80D6 CA              	   162:   dex
                        	   163: _dispatch_miss_1:
00:80D7 E8              	   164:   inx
00:80D8 E8              	   165:   inx
00:80D9 E8              	   166:   inx
00:80DA E8              	   167:   inx
00:80DB E8              	   168:   inx
00:80DC A000            	   169:   ldy #0
00:80DE 60              	   170:   rts
                        	   171: 
                        	   172: ; not a subroutine like the others, you can jump here if you
                        	   173: ; encounter an error in parsing
                        	   174: bad_handler:
00:80DF A9C9            	   175:   lda #err_msg
00:80E1 8550            	   176:   sta PRINT
00:80E3 A981            	   177:   lda #>err_msg
00:80E5 8551            	   178:   sta PRINT+1
00:80E7 209481          	   179:   jsr print
00:80EA 4C0E80          	   180:   jmp mainloop
                        	   181: 
                        	   182: ; buffer a line of input, null-terminated.
                        	   183: get_line:
00:80ED A200            	   184:   ldx #0
00:80EF 8610            	   185:   stx input_ptr
                        	   186: _get_line_loop:
00:80F1 AD0280          	   187:   lda SERIAL
00:80F4 F0FB            	   188:   beq _get_line_loop ; if no key pressed, check again
                        	   189:   
00:80F6 C90A            	   190:   cmp #NEWLINE ; if enter pressed, write a null and exit
00:80F8 F016            	   191:   beq _get_line_done
                        	   192: 
00:80FA C97F            	   193:   cmp #DELETE ; if backspace pressed, remove last char
00:80FC F018            	   194:   beq _get_line_backspace
00:80FE C908            	   195:   cmp #BACKSPACE ; either of these codes may be emitted for a backspace by different terminals
00:8100 F014            	   196:   beq _get_line_backspace
                        	   197: 
00:8102 C91B            	   198:   cmp #ESCAPE
00:8104 F023            	   199:   beq _get_line_escape ; if escape was pressed, immediately exit
                        	   200: 
00:8106 9D0002          	   201:   sta input_buf,x ; write the char to the input buffer
00:8109 8D0280          	   202:   sta SERIAL ; echo back the char
00:810C E8              	   203:   inx
00:810D 4CF180          	   204:   jmp _get_line_loop
                        	   205: _get_line_done:
00:8110 A900            	   206:   lda #0
00:8112 9D0002          	   207:   sta input_buf,x
00:8115 60              	   208:   rts
                        	   209: _get_line_backspace:
00:8116 A908            	   210:   lda #BACKSPACE
00:8118 8D0280          	   211:   sta SERIAL
00:811B A920            	   212:   lda #" "
00:811D 8D0280          	   213:   sta SERIAL
00:8120 A908            	   214:   lda #BACKSPACE
00:8122 8D0280          	   215:   sta SERIAL
00:8125 CA              	   216:   dex
                        	   217: _get_line_backspace_ignore:
00:8126 4CF180          	   218:   jmp _get_line_loop
                        	   219: _get_line_escape:
00:8129 A9B8            	   220:   lda #end_msg
00:812B 8550            	   221:   sta PRINT
00:812D A981            	   222:   lda #>end_msg
00:812F 8551            	   223:   sta PRINT + 1
00:8131 209481          	   224:   jsr print
00:8134 6CF8FF          	   225:   jmp (EXIT_VEC)
                        	   226: 
                        	   227: ; expect from the input buffer and return (in a) a single key, ignoring spaces
                        	   228: ; modifies: a, x, y
                        	   229: get_key:
00:8137 A610            	   230:   ldx input_ptr
00:8139 E610            	   231:   inc input_ptr ; move the buf ptr to the next char for the next call to get_Key
00:813B BD0002          	   232:   lda input_buf,x ; read the key from the buf
00:813E F09F            	   233:   beq bad_handler ; if the input buffer is exhausted, throw error
00:8140 C940            	   234:   cmp #"@"     ; if "@" was pressed,
00:8142 F005            	   235:   beq _get_key_new_addr  ; move to a new address.
00:8144 C920            	   236:   cmp #" "     ; if space was pressed,
00:8146 F0EF            	   237:   beq get_key  ; skip the key.
00:8148 60              	   238:   rts
                        	   239: 
                        	   240: _get_key_new_addr:
00:8149 208581          	   241:   jsr get_byte ; expect a 2 byte memory address
00:814C 8531            	   242:   sta insert_ptr+1
00:814E 208581          	   243:   jsr get_byte
00:8151 8530            	   244:   sta insert_ptr ; move to the new address
00:8153 A90A            	   245:   lda #NEWLINE ; print a newline, to create a new visual block
00:8155 8D0280          	   246:   sta SERIAL
00:8158 4C0E80          	   247:   jmp mainloop
                        	   248: 
                        	   249: ; wait for a key and return (in a) the value of a single hex char
                        	   250: ; modifies: a (duh)
                        	   251: get_nibble:
00:815B 203781          	   252:   jsr get_key
00:815E C93A            	   253:   cmp #$3a
00:8160 9004            	   254:   bcc _get_nibble_digit
00:8162 38              	   255:   sec
00:8163 E957            	   256:   sbc #"a" - 10
00:8165 60              	   257:   rts
                        	   258: _get_nibble_digit:
00:8166 E92F            	   259:   sbc #"0" - 1
00:8168 60              	   260:   rts
                        	   261: 
                        	   262: ; return (in a) the a register as hex
                        	   263: ; modifies: a (duh)
                        	   264: hex_nibble:
00:8169 C90A            	   265:   cmp #10
00:816B 9004            	   266:   bcc _hex_nibble_digit
00:816D 18              	   267:   clc
00:816E 6957            	   268:   adc #"a" - 10
00:8170 60              	   269:   rts
                        	   270: _hex_nibble_digit:
00:8171 6930            	   271:   adc #"0"
00:8173 60              	   272:   rts
                        	   273: 
                        	   274: ; return (in x & y) the a register as hex
                        	   275: ; modifies: x, y, a
                        	   276: hex_byte:
00:8174 48              	   277:   pha ; save the full value for later
                        	   278:   ; get just the MSN
00:8175 4A              	   279:   lsr
00:8176 4A              	   280:   lsr
00:8177 4A              	   281:   lsr
00:8178 4A              	   282:   lsr
00:8179 206981          	   283:   jsr hex_nibble
00:817C AA              	   284:   tax ; but the hex char for the MSN in x
                        	   285: 
00:817D 68              	   286:   pla ; bring back the full value
00:817E 290F            	   287:   and #$0f ; get just the LSN
00:8180 206981          	   288:   jsr hex_nibble
00:8183 A8              	   289:   tay ; but the hex char for the LSN in y
                        	   290: 
00:8184 60              	   291:   rts
                        	   292: 
                        	   293: ; wait for a key and return (in a) the value of a byte (2 hex chars)
                        	   294: ; modifies: a (duh)
                        	   295: get_byte:
                        	   296:   ; get the MS nibble and move it to the MS area of the a reg
00:8185 205B81          	   297:   jsr get_nibble
00:8188 0A              	   298:   asl
00:8189 0A              	   299:   asl
00:818A 0A              	   300:   asl
00:818B 0A              	   301:   asl
                        	   302:   ; move the MSN to memory
00:818C 8540            	   303:   sta BYTE_BUILD
                        	   304: 
                        	   305:   ; get the LSN and combine it with the MSN
00:818E 205B81          	   306:   jsr get_nibble
00:8191 0540            	   307:   ora BYTE_BUILD
00:8193 60              	   308:   rts
                        	   309: 
                        	   310: ; write the address of a null-terminated string to PRINT
                        	   311: ; modifies: a
                        	   312: print:
00:8194 98              	   313:   tya
00:8195 48              	   314:   pha
00:8196 A000            	   315:   ldy #0
                        	   316: _print_loop:
00:8198 B150            	   317:   lda (PRINT),y
00:819A F007            	   318:   beq _print_done
00:819C 8D0280          	   319:   sta SERIAL
00:819F C8              	   320:   iny
00:81A0 4C9881          	   321:   jmp _print_loop
                        	   322: _print_done:
00:81A3 68              	   323:   pla
00:81A4 A8              	   324:   tay
00:81A5 60              	   325:   rts
                        	   326: 
                        	   327: start_msg:
00:81A6 0A              	   328:   .byte NEWLINE, NEWLINE
00:81A7 0A
00:81A8 286D6E656D6F6E69	   329:   .byte "(mnemonic mode)"
00:81B0 63206D6F646529
00:81B7 00              	   330:   .byte 0
                        	   331: 
                        	   332: end_msg:
00:81B8 0A              	   333:   .byte NEWLINE, NEWLINE
00:81B9 0A
00:81BA 286E6F726D616C20	   334:   .byte "(normal mode)"
00:81C2 6D6F646529
00:81C7 0A              	   335:   .byte NEWLINE
00:81C8 00              	   336:   .byte 0
                        	   337: 
                        	   338: err_msg:
00:81C9 0A              	   339:   .byte NEWLINE
00:81CA 73796E7461782065	   340:   .byte "syntax error. check your new memory address before continuing."
00:81D2 72726F722E206368
00:81DA 65636B20796F7572
00:81E2 206E6577206D656D
00:81EA 6F72792061646472
00:81F2 657373206265666F
00:81FA 726520636F6E7469
00:8202 6E75696E672E
00:8208 0A              	   341:   .byte NEWLINE
00:8209 00              	   342:   .byte 0
                        	   343: 
                        	   344: ; opcode handlers:
                        	   345: lda_handler:
00:820A 203781          	   346:   jsr get_key
00:820D C923            	   347:   cmp #"#"
00:820F D00C            	   348:   bne _lda_fail   ; TODO: add support for other addressing modes
00:8211 A9A9            	   349:   lda #$a9        ; insert the opcode
00:8213 204280          	   350:   jsr insert_a
00:8216 205A80          	   351:   jsr get_val     ; insert the immediate value
00:8219 204280          	   352:   jsr insert_a
00:821C 60              	   353:   rts
                        	   354: _lda_fail:
00:821D 4CDF80          	   355:   jmp bad_handler
                        	   356: 
                        	   357: sta_handler:
00:8220 A98D            	   358:   lda #$8d
00:8222 204280          	   359:   jsr insert_a
00:8225 207580          	   360:   jsr get_word
00:8228 204A80          	   361:   jsr insert_ax
00:822B 60              	   362:   rts
                        	   363: 
                        	   364: stx_handler:
00:822C A98E            	   365:   lda #$8e
00:822E 204280          	   366:   jsr insert_a
00:8231 207580          	   367:   jsr get_word
00:8234 204A80          	   368:   jsr insert_ax
00:8237 60              	   369:   rts
                        	   370: 
                        	   371: sty_handler:
00:8238 A98C            	   372:   lda #$8c
00:823A 204280          	   373:   jsr insert_a
00:823D 207580          	   374:   jsr get_word
00:8240 204A80          	   375:   jsr insert_ax
00:8243 60              	   376:   rts
                        	   377: 
                        	   378: jsr_handler:
00:8244 A920            	   379:   lda #$20
00:8246 204280          	   380:   jsr insert_a
00:8249 207580          	   381:   jsr get_word
00:824C 204A80          	   382:   jsr insert_ax
00:824F 60              	   383:   rts
                        	   384: 
                        	   385: rts_handler:
00:8250 A960            	   386:   lda #$60
00:8252 204280          	   387:   jsr insert_a
00:8255 60              	   388:   rts
                        	   389: 
                        	   390: ; note to self: make sure to order these roughly by usage, so that
                        	   391: ; dispatching is faster
                        	   392: opcode_table:
00:8256 6C6461          	   393:   .byte "lda"
00:8259 0A82            	   394:   .word lda_handler
00:825B 737461          	   395:   .byte "sta"
00:825E 2082            	   396:   .word sta_handler
00:8260 6A7372          	   397:   .byte "jsr"
00:8263 4482            	   398:   .word jsr_handler
00:8265 737478          	   399:   .byte "stx"
00:8268 2C82            	   400:   .word stx_handler
00:826A 737479          	   401:   .byte "sty"
00:826D 3882            	   402:   .word sty_handler
00:826F 727473          	   403:   .byte "rts"
00:8272 5082            	   404:   .word rts_handler
                        	   405: 


Symbols by name:
BACKSPACE                        E:0008
BYTE_BUILD                       E:0040
DELETE                           E:007F
ESCAPE                           E:001B
EXIT_VEC                         E:FFF8
NEWLINE                          E:000A
PRINT                            E:0050
SERIAL                           E:8002
_dispatch_loop_fail              A:8038
_dispatch_miss_1                 A:80D7
_dispatch_miss_2                 A:80D6
_dispatch_miss_3                 A:80D5
_dispatch_run                    A:80D2
_get_key_new_addr                A:8149
_get_line_backspace              A:8116
_get_line_backspace_ignore       A:8126
_get_line_done                   A:8110
_get_line_escape                 A:8129
_get_line_loop                   A:80F1
_get_nibble_digit                A:8166
_get_val_not_char                A:8072
_get_val_not_hex                 A:8065
_get_word_fail                   A:8086
_hex_nibble_digit                A:8171
_inc_insert_done                 A:8041
_lda_fail                        A:821D
_print_done                      A:81A3
_print_loop                      A:8198
bad_handler                      A:80DF
dispatch                         A:80AA
dispatch_loop                    A:802A
end_msg                          A:81B8
err_msg                          A:81C9
get_byte                         A:8185
get_key                          A:8137
get_line                         A:80ED
get_nibble                       A:815B
get_val                          A:805A
get_word                         A:8075
hex_byte                         A:8174
hex_nibble                       A:8169
inc_insert                       A:803B
input_buf                        E:0200
input_ptr                        E:0010
insert_a                         A:8042
insert_ax                        A:804A
insert_ptr                       E:0030
jsr_handler                      A:8244
lda_handler                      A:820A
main                             A:8003
mainloop                         A:800E
opc_buf                          E:0020
opc_handler                      E:0023
opcode_table                     A:8256
print                            A:8194
print_addr                       A:8089
rts_handler                      A:8250
sta_handler                      A:8220
start_msg                        A:81A6
stx_handler                      A:822C
sty_handler                      A:8238

Symbols by value:
0008 BACKSPACE
000A NEWLINE
0010 input_ptr
001B ESCAPE
0020 opc_buf
0023 opc_handler
0030 insert_ptr
0040 BYTE_BUILD
0050 PRINT
007F DELETE
0200 input_buf
8002 SERIAL
8003 main
800E mainloop
802A dispatch_loop
8038 _dispatch_loop_fail
803B inc_insert
8041 _inc_insert_done
8042 insert_a
804A insert_ax
805A get_val
8065 _get_val_not_hex
8072 _get_val_not_char
8075 get_word
8086 _get_word_fail
8089 print_addr
80AA dispatch
80D2 _dispatch_run
80D5 _dispatch_miss_3
80D6 _dispatch_miss_2
80D7 _dispatch_miss_1
80DF bad_handler
80ED get_line
80F1 _get_line_loop
8110 _get_line_done
8116 _get_line_backspace
8126 _get_line_backspace_ignore
8129 _get_line_escape
8137 get_key
8149 _get_key_new_addr
815B get_nibble
8166 _get_nibble_digit
8169 hex_nibble
8171 _hex_nibble_digit
8174 hex_byte
8185 get_byte
8194 print
8198 _print_loop
81A3 _print_done
81A6 start_msg
81B8 end_msg
81C9 err_msg
820A lda_handler
821D _lda_fail
8220 sta_handler
822C stx_handler
8238 sty_handler
8244 jsr_handler
8250 rts_handler
8256 opcode_table
FFF8 EXIT_VEC
