Sections:
00: "org0001:8003" (8003-82F4)


Source: "programs/assembler.asm"
                        	     1:   .org $8003
                        	     2: 
                        	     3: ; memory map:
                        	     4: SERIAL   = $8002
                        	     5: EXIT_VEC = $fff8
                        	     6: 
                        	     7: ; ascii codes:
                        	     8: NEWLINE   = $0a
                        	     9: ESCAPE    = $1b
                        	    10: DELETE    = $7f
                        	    11: BACKSPACE = $08
                        	    12: 
                        	    13: ; memory allocation:
                        	    14: BYTE_BUILD  = $40     ; 1 byte
                        	    15: PRINT       = $50     ;  1byte
                        	    16: opc_buf     = $20     ; 3 bytes 
                        	    17: opc_handler = $23     ; 2 bytes
                        	    18: insert_ptr  = $30     ; 2 bytes (matches the monitor)
                        	    19: input_buf   = $0200   ; 256 bytes
                        	    20: input_ptr   = $10     ; 1 bytes
                        	    21: word_build  = $05     ; 2 bytes
                        	    22: 
                        	    23: main:
00:8003 A9A6            	    24:   lda #start_msg
00:8005 8550            	    25:   sta PRINT
00:8007 A981            	    26:   lda #>start_msg
00:8009 8551            	    27:   sta PRINT + 1
00:800B 209481          	    28:   jsr print
                        	    29: 
                        	    30: mainloop:
00:800E A90A            	    31:   lda #NEWLINE
00:8010 8D0280          	    32:   sta SERIAL
00:8013 208980          	    33:   jsr print_addr
00:8016 20ED80          	    34:   jsr get_line
00:8019 203781          	    35:   jsr get_key
00:801C 8520            	    36:   sta opc_buf
00:801E 203781          	    37:   jsr get_key
00:8021 8521            	    38:   sta opc_buf+1
00:8023 203781          	    39:   jsr get_key
00:8026 8522            	    40:   sta opc_buf+2
                        	    41: 
00:8028 A200            	    42:   ldx #0            ; start checking at the first opcode in the table
                        	    43: dispatch_loop:
00:802A 20AA80          	    44:   jsr dispatch      ; run the opcode handler if it matches and move on
00:802D C001            	    45:   cpy #1            ; if a match was not found,
00:802F D0F9            	    46:   bne dispatch_loop ; keep going.
00:8031 E0F9            	    47:   cpx #249          ; if the table is exhausted,
00:8033 B003            	    48:   bcs _dispatch_loop_fail   ; the opcode is unknown. 
00:8035 4C0E80          	    49:   jmp mainloop      ; otherwise, read the next opcode
                        	    50: _dispatch_loop_fail:
00:8038 4CDF80          	    51:   jmp bad_handler
                        	    52: 
                        	    53: ; increment the insertion pointer
                        	    54: inc_insert:
00:803B E630            	    55:   inc insert_ptr
00:803D D002            	    56:   bne _inc_insert_done
00:803F E631            	    57:   inc insert_ptr+1
                        	    58: _inc_insert_done:
00:8041 60              	    59:   rts
                        	    60: 
                        	    61: ; insert the a register and move on
                        	    62: insert_a:
00:8042 A000            	    63:   ldy #0
00:8044 9130            	    64:   sta (insert_ptr),y
00:8046 203B80          	    65:   jsr inc_insert
00:8049 60              	    66:   rts
                        	    67: 
                        	    68: ; insert the x and a registers and move on
                        	    69: insert_ax:
00:804A A000            	    70:   ldy #0
00:804C 48              	    71:   pha
00:804D 8A              	    72:   txa
00:804E 9130            	    73:   sta (insert_ptr),y
00:8050 203B80          	    74:   jsr inc_insert
00:8053 68              	    75:   pla
00:8054 9130            	    76:   sta (insert_ptr),y
00:8056 203B80          	    77:   jsr inc_insert
00:8059 60              	    78:   rts
                        	    79: 
                        	    80: ; get a value in hex, and return it in A (TODO: support binary (%) and decimal)
                        	    81: get_val:
00:805A 203781          	    82:   jsr get_key
00:805D C924            	    83:   cmp #"$"
00:805F D004            	    84:   bne _get_val_not_hex
00:8061 208581          	    85:   jsr get_byte
00:8064 60              	    86:   rts
                        	    87: _get_val_not_hex:
                        	    88: 
00:8065 C922            	    89:   cmp #$22 ; double quote
00:8067 D009            	    90:   bne _get_val_not_char
00:8069 203781          	    91:   jsr get_key
00:806C 48              	    92:   pha
00:806D 203781          	    93:   jsr get_key
00:8070 68              	    94:   pla
00:8071 60              	    95:   rts
                        	    96: 
                        	    97: _get_val_not_char:
00:8072 4CDF80          	    98:   jmp bad_handler
                        	    99: 
                        	   100: ; get a word in hex and return it in a and x
                        	   101: get_word:
00:8075 203781          	   102:   jsr get_key
00:8078 C924            	   103:   cmp #"$"
00:807A D00A            	   104:   bne _get_word_fail
00:807C 208581          	   105:   jsr get_byte
00:807F 48              	   106:   pha
00:8080 208581          	   107:   jsr get_byte
00:8083 AA              	   108:   tax
00:8084 68              	   109:   pla
00:8085 60              	   110:   rts
                        	   111: _get_word_fail:
00:8086 4CDF80          	   112:   jmp bad_handler
                        	   113: 
                        	   114: ; print the insertion pointer
                        	   115: print_addr:
00:8089 A531            	   116:   lda insert_ptr+1
00:808B 207481          	   117:   jsr hex_byte
00:808E 8E0280          	   118:   stx SERIAL
00:8091 8C0280          	   119:   sty SERIAL
00:8094 A530            	   120:   lda insert_ptr
00:8096 207481          	   121:   jsr hex_byte
00:8099 8E0280          	   122:   stx SERIAL
00:809C 8C0280          	   123:   sty SERIAL
00:809F A93A            	   124:   lda #":"
00:80A1 8D0280          	   125:   sta SERIAL
00:80A4 A920            	   126:   lda #" "
00:80A6 8D0280          	   127:   sta SERIAL
00:80A9 60              	   128:   rts
                        	   129: 
                        	   130: ; 1. match the xth element in the opcode table with the input buffer
                        	   131: ; 2. if it matches, call the opcode handler
                        	   132: ; 3. increment x by 5
                        	   133: ; 4. return in y 1 if the opcode matched, otherwise 0
                        	   134: dispatch:
00:80AA BDA482          	   135:   lda opcode_table,x
00:80AD C520            	   136:   cmp opc_buf
00:80AF D026            	   137:   bne _dispatch_miss_1
00:80B1 E8              	   138:   inx
00:80B2 BDA482          	   139:   lda opcode_table,x
00:80B5 C521            	   140:   cmp opc_buf+1
00:80B7 D01D            	   141:   bne _dispatch_miss_2
00:80B9 E8              	   142:   inx
00:80BA BDA482          	   143:   lda opcode_table,x
00:80BD C522            	   144:   cmp opc_buf+2
00:80BF D014            	   145:   bne _dispatch_miss_3
00:80C1 E8              	   146:   inx
                        	   147: 
00:80C2 BDA482          	   148:   lda opcode_table,x
00:80C5 8523            	   149:   sta opc_handler
00:80C7 BDA582          	   150:   lda opcode_table+1,x
00:80CA 8524            	   151:   sta opc_handler+1
                        	   152: 
                        	   153:   ; there is no indirect jsr, so we do this
00:80CC 20D280          	   154:   jsr _dispatch_run
00:80CF A001            	   155:   ldy #1
00:80D1 60              	   156:   rts
                        	   157: _dispatch_run:
00:80D2 6C2300          	   158:   jmp (opc_handler)
                        	   159: 
                        	   160: _dispatch_miss_3:
00:80D5 CA              	   161:   dex
                        	   162: _dispatch_miss_2:
00:80D6 CA              	   163:   dex
                        	   164: _dispatch_miss_1:
00:80D7 E8              	   165:   inx
00:80D8 E8              	   166:   inx
00:80D9 E8              	   167:   inx
00:80DA E8              	   168:   inx
00:80DB E8              	   169:   inx
00:80DC A000            	   170:   ldy #0
00:80DE 60              	   171:   rts
                        	   172: 
                        	   173: ; not a subroutine like the others, you can jump here if you
                        	   174: ; encounter an error in parsing
                        	   175: bad_handler:
00:80DF A9C9            	   176:   lda #err_msg
00:80E1 8550            	   177:   sta PRINT
00:80E3 A981            	   178:   lda #>err_msg
00:80E5 8551            	   179:   sta PRINT+1
00:80E7 209481          	   180:   jsr print
00:80EA 4C0E80          	   181:   jmp mainloop
                        	   182: 
                        	   183: ; buffer a line of input, null-terminated.
                        	   184: get_line:
00:80ED A200            	   185:   ldx #0
00:80EF 8610            	   186:   stx input_ptr
                        	   187: _get_line_loop:
00:80F1 AD0280          	   188:   lda SERIAL
00:80F4 F0FB            	   189:   beq _get_line_loop ; if no key pressed, check again
                        	   190:   
00:80F6 C90A            	   191:   cmp #NEWLINE ; if enter pressed, write a null and exit
00:80F8 F016            	   192:   beq _get_line_done
                        	   193: 
00:80FA C97F            	   194:   cmp #DELETE ; if backspace pressed, remove last char
00:80FC F018            	   195:   beq _get_line_backspace
00:80FE C908            	   196:   cmp #BACKSPACE ; either of these codes may be emitted for a backspace by different terminals
00:8100 F014            	   197:   beq _get_line_backspace
                        	   198: 
00:8102 C91B            	   199:   cmp #ESCAPE
00:8104 F023            	   200:   beq _get_line_escape ; if escape was pressed, immediately exit
                        	   201: 
00:8106 9D0002          	   202:   sta input_buf,x ; write the char to the input buffer
00:8109 8D0280          	   203:   sta SERIAL ; echo back the char
00:810C E8              	   204:   inx
00:810D 4CF180          	   205:   jmp _get_line_loop
                        	   206: _get_line_done:
00:8110 A900            	   207:   lda #0
00:8112 9D0002          	   208:   sta input_buf,x
00:8115 60              	   209:   rts
                        	   210: _get_line_backspace:
00:8116 A908            	   211:   lda #BACKSPACE
00:8118 8D0280          	   212:   sta SERIAL
00:811B A920            	   213:   lda #" "
00:811D 8D0280          	   214:   sta SERIAL
00:8120 A908            	   215:   lda #BACKSPACE
00:8122 8D0280          	   216:   sta SERIAL
00:8125 CA              	   217:   dex
                        	   218: _get_line_backspace_ignore:
00:8126 4CF180          	   219:   jmp _get_line_loop
                        	   220: _get_line_escape:
00:8129 A9B8            	   221:   lda #end_msg
00:812B 8550            	   222:   sta PRINT
00:812D A981            	   223:   lda #>end_msg
00:812F 8551            	   224:   sta PRINT + 1
00:8131 209481          	   225:   jsr print
00:8134 6CF8FF          	   226:   jmp (EXIT_VEC)
                        	   227: 
                        	   228: ; expect from the input buffer and return (in a) a single key, ignoring spaces
                        	   229: ; modifies: a, x, y
                        	   230: get_key:
00:8137 A610            	   231:   ldx input_ptr
00:8139 E610            	   232:   inc input_ptr ; move the buf ptr to the next char for the next call to get_Key
00:813B BD0002          	   233:   lda input_buf,x ; read the key from the buf
00:813E F09F            	   234:   beq bad_handler ; if the input buffer is exhausted, throw error
00:8140 C940            	   235:   cmp #"@"     ; if "@" was pressed,
00:8142 F005            	   236:   beq _get_key_new_addr  ; move to a new address.
00:8144 C920            	   237:   cmp #" "     ; if space was pressed,
00:8146 F0EF            	   238:   beq get_key  ; skip the key.
00:8148 60              	   239:   rts
                        	   240: 
                        	   241: _get_key_new_addr:
00:8149 208581          	   242:   jsr get_byte ; expect a 2 byte memory address
00:814C 8531            	   243:   sta insert_ptr+1
00:814E 208581          	   244:   jsr get_byte
00:8151 8530            	   245:   sta insert_ptr ; move to the new address
00:8153 A90A            	   246:   lda #NEWLINE ; print a newline, to create a new visual block
00:8155 8D0280          	   247:   sta SERIAL
00:8158 4C0E80          	   248:   jmp mainloop
                        	   249: 
                        	   250: ; wait for a key and return (in a) the value of a single hex char
                        	   251: ; modifies: a (duh)
                        	   252: get_nibble:
00:815B 203781          	   253:   jsr get_key
00:815E C93A            	   254:   cmp #$3a
00:8160 9004            	   255:   bcc _get_nibble_digit
00:8162 38              	   256:   sec
00:8163 E957            	   257:   sbc #"a" - 10
00:8165 60              	   258:   rts
                        	   259: _get_nibble_digit:
00:8166 E92F            	   260:   sbc #"0" - 1
00:8168 60              	   261:   rts
                        	   262: 
                        	   263: ; return (in a) the a register as hex
                        	   264: ; modifies: a (duh)
                        	   265: hex_nibble:
00:8169 C90A            	   266:   cmp #10
00:816B 9004            	   267:   bcc _hex_nibble_digit
00:816D 18              	   268:   clc
00:816E 6957            	   269:   adc #"a" - 10
00:8170 60              	   270:   rts
                        	   271: _hex_nibble_digit:
00:8171 6930            	   272:   adc #"0"
00:8173 60              	   273:   rts
                        	   274: 
                        	   275: ; return (in x & y) the a register as hex
                        	   276: ; modifies: x, y, a
                        	   277: hex_byte:
00:8174 48              	   278:   pha ; save the full value for later
                        	   279:   ; get just the MSN
00:8175 4A              	   280:   lsr
00:8176 4A              	   281:   lsr
00:8177 4A              	   282:   lsr
00:8178 4A              	   283:   lsr
00:8179 206981          	   284:   jsr hex_nibble
00:817C AA              	   285:   tax ; but the hex char for the MSN in x
                        	   286: 
00:817D 68              	   287:   pla ; bring back the full value
00:817E 290F            	   288:   and #$0f ; get just the LSN
00:8180 206981          	   289:   jsr hex_nibble
00:8183 A8              	   290:   tay ; but the hex char for the LSN in y
                        	   291: 
00:8184 60              	   292:   rts
                        	   293: 
                        	   294: ; wait for a key and return (in a) the value of a byte (2 hex chars)
                        	   295: ; modifies: a (duh)
                        	   296: get_byte:
                        	   297:   ; get the MS nibble and move it to the MS area of the a reg
00:8185 205B81          	   298:   jsr get_nibble
00:8188 0A              	   299:   asl
00:8189 0A              	   300:   asl
00:818A 0A              	   301:   asl
00:818B 0A              	   302:   asl
                        	   303:   ; move the MSN to memory
00:818C 8540            	   304:   sta BYTE_BUILD
                        	   305: 
                        	   306:   ; get the LSN and combine it with the MSN
00:818E 205B81          	   307:   jsr get_nibble
00:8191 0540            	   308:   ora BYTE_BUILD
00:8193 60              	   309:   rts
                        	   310: 
                        	   311: ; write the address of a null-terminated string to PRINT
                        	   312: ; modifies: a
                        	   313: print:
00:8194 98              	   314:   tya
00:8195 48              	   315:   pha
00:8196 A000            	   316:   ldy #0
                        	   317: _print_loop:
00:8198 B150            	   318:   lda (PRINT),y
00:819A F007            	   319:   beq _print_done
00:819C 8D0280          	   320:   sta SERIAL
00:819F C8              	   321:   iny
00:81A0 4C9881          	   322:   jmp _print_loop
                        	   323: _print_done:
00:81A3 68              	   324:   pla
00:81A4 A8              	   325:   tay
00:81A5 60              	   326:   rts
                        	   327: 
                        	   328: start_msg:
00:81A6 0A              	   329:   .byte NEWLINE, NEWLINE
00:81A7 0A
00:81A8 286D6E656D6F6E69	   330:   .byte "(mnemonic mode)"
00:81B0 63206D6F646529
00:81B7 00              	   331:   .byte 0
                        	   332: 
                        	   333: end_msg:
00:81B8 0A              	   334:   .byte NEWLINE, NEWLINE
00:81B9 0A
00:81BA 286E6F726D616C20	   335:   .byte "(normal mode)"
00:81C2 6D6F646529
00:81C7 0A              	   336:   .byte NEWLINE
00:81C8 00              	   337:   .byte 0
                        	   338: 
                        	   339: err_msg:
00:81C9 0A              	   340:   .byte NEWLINE
00:81CA 73796E7461782065	   341:   .byte "syntax error. check your new memory address before continuing."
00:81D2 72726F722E206368
00:81DA 65636B20796F7572
00:81E2 206E6577206D656D
00:81EA 6F72792061646472
00:81F2 657373206265666F
00:81FA 726520636F6E7469
00:8202 6E75696E672E
00:8208 0A              	   342:   .byte NEWLINE
00:8209 00              	   343:   .byte 0
                        	   344: 
                        	   345: ; opcode handlers:
                        	   346: lda_handler:
                        	   347:   ; immediate addressing
00:820A 203781          	   348:   jsr get_key
00:820D C923            	   349:   cmp #"#"
00:820F D00C            	   350:   bne _lda_not_immediate   ; TODO: add support for other addressing modes
00:8211 A9A9            	   351:   lda #$a9        ; insert the opcode
00:8213 204280          	   352:   jsr insert_a
00:8216 205A80          	   353:   jsr get_val     ; insert the immediate value
00:8219 204280          	   354:   jsr insert_a
00:821C 60              	   355:   rts
                        	   356: _lda_not_immediate:
                        	   357:   ; absolute addressing
00:821D C924            	   358:   cmp #"$"
00:821F D00E            	   359:   bne _lda_fail
00:8221 A9AD            	   360:   lda #$ad
00:8223 204280          	   361:   jsr insert_a
00:8226 C610            	   362:   dec input_ptr
00:8228 207580          	   363:   jsr get_word
00:822B 204A80          	   364:   jsr insert_ax
00:822E 60              	   365:   rts
                        	   366: _lda_fail:
00:822F 4CDF80          	   367:   jmp bad_handler
                        	   368: sta_handler:
00:8232 A98D            	   369:   lda #$8d
00:8234 204280          	   370:   jsr insert_a
00:8237 207580          	   371:   jsr get_word
00:823A 204A80          	   372:   jsr insert_ax
00:823D 60              	   373:   rts
                        	   374: stx_handler:
00:823E A98E            	   375:   lda #$8e
00:8240 204280          	   376:   jsr insert_a
00:8243 207580          	   377:   jsr get_word
00:8246 204A80          	   378:   jsr insert_ax
00:8249 60              	   379:   rts
                        	   380: sty_handler:
00:824A A98C            	   381:   lda #$8c
00:824C 204280          	   382:   jsr insert_a
00:824F 207580          	   383:   jsr get_word
00:8252 204A80          	   384:   jsr insert_ax
00:8255 60              	   385:   rts
                        	   386: 
                        	   387: jsr_handler:
00:8256 A920            	   388:   lda #$20
00:8258 204280          	   389:   jsr insert_a
00:825B 207580          	   390:   jsr get_word
00:825E 204A80          	   391:   jsr insert_ax
00:8261 60              	   392:   rts
                        	   393: rts_handler:
00:8262 A960            	   394:   lda #$60
00:8264 204280          	   395:   jsr insert_a
00:8267 60              	   396:   rts
                        	   397: 
                        	   398: tax_handler:
00:8268 A9AA            	   399:   lda #$aa
00:826A 204280          	   400:   jsr insert_a
00:826D 60              	   401:   rts
                        	   402: tay_handler:
00:826E A9A8            	   403:   lda #$a8
00:8270 204280          	   404:   jsr insert_a
00:8273 60              	   405:   rts
                        	   406: txa_handler:
00:8274 A98A            	   407:   lda #$8a
00:8276 204280          	   408:   jsr insert_a
00:8279 60              	   409:   rts
                        	   410: tya_handler:
00:827A A998            	   411:   lda #$98
00:827C 204280          	   412:   jsr insert_a
00:827F 60              	   413:   rts
                        	   414: 
                        	   415: tsx_handler:
00:8280 A9BA            	   416:   lda #$ba
00:8282 204280          	   417:   jsr insert_a
00:8285 60              	   418:   rts
                        	   419: txs_handler:
00:8286 A99A            	   420:   lda #$9a
00:8288 204280          	   421:   jsr insert_a
00:828B 60              	   422:   rts
                        	   423: pha_handler:
00:828C A948            	   424:   lda #$48
00:828E 204280          	   425:   jsr insert_a
00:8291 60              	   426:   rts
                        	   427: php_handler:
00:8292 A908            	   428:   lda #$08
00:8294 204280          	   429:   jsr insert_a
00:8297 60              	   430:   rts
                        	   431: pla_handler:
00:8298 A968            	   432:   lda #$68
00:829A 204280          	   433:   jsr insert_a
00:829D 60              	   434:   rts
                        	   435: plp_handler:
00:829E A928            	   436:   lda #$28
00:82A0 204280          	   437:   jsr insert_a
00:82A3 60              	   438:   rts
                        	   439: 
                        	   440: ; note to self: make sure to order these roughly by usage, so that
                        	   441: ; dispatching is faster
                        	   442: ; note to self: 56 instructions * 5 bytes in 280 bytes! not all instructions will fit.
                        	   443: ; luckily, the os does not use interrupts, so the interrupt instructions can go, which
                        	   444: ; makes it fit. lucky!
                        	   445: opcode_table:
00:82A4 6C6461          	   446:   .byte "lda"
00:82A7 0A82            	   447:   .word lda_handler
00:82A9 737461          	   448:   .byte "sta"
00:82AC 3282            	   449:   .word sta_handler
00:82AE 737478          	   450:   .byte "stx"
00:82B1 3E82            	   451:   .word stx_handler
00:82B3 737479          	   452:   .byte "sty"
00:82B6 4A82            	   453:   .word sty_handler
                        	   454: 
00:82B8 727473          	   455:   .byte "rts"
00:82BB 6282            	   456:   .word rts_handler
00:82BD 6A7372          	   457:   .byte "jsr"
00:82C0 5682            	   458:   .word jsr_handler
                        	   459: 
00:82C2 746178          	   460:   .byte "tax"
00:82C5 6882            	   461:   .word tax_handler
00:82C7 746179          	   462:   .byte "tay"
00:82CA 6E82            	   463:   .word tay_handler
00:82CC 747861          	   464:   .byte "txa"
00:82CF 7482            	   465:   .word txa_handler
00:82D1 747961          	   466:   .byte "tya"
00:82D4 7A82            	   467:   .word tya_handler
                        	   468: 
00:82D6 747378          	   469:   .byte "tsx"
00:82D9 8082            	   470:   .word tsx_handler
00:82DB 747873          	   471:   .byte "txs"
00:82DE 8682            	   472:   .word txs_handler
00:82E0 706861          	   473:   .byte "pha"
00:82E3 8C82            	   474:   .word pha_handler
00:82E5 706870          	   475:   .byte "php"
00:82E8 9282            	   476:   .word php_handler
00:82EA 706C61          	   477:   .byte "pla"
00:82ED 9882            	   478:   .word pla_handler
00:82EF 706C70          	   479:   .byte "plp"
00:82F2 9E82            	   480:   .word plp_handler
                        	   481: 


Symbols by name:
BACKSPACE                        E:0008
BYTE_BUILD                       E:0040
DELETE                           E:007F
ESCAPE                           E:001B
EXIT_VEC                         E:FFF8
NEWLINE                          E:000A
PRINT                            E:0050
SERIAL                           E:8002
_dispatch_loop_fail              A:8038
_dispatch_miss_1                 A:80D7
_dispatch_miss_2                 A:80D6
_dispatch_miss_3                 A:80D5
_dispatch_run                    A:80D2
_get_key_new_addr                A:8149
_get_line_backspace              A:8116
_get_line_backspace_ignore       A:8126
_get_line_done                   A:8110
_get_line_escape                 A:8129
_get_line_loop                   A:80F1
_get_nibble_digit                A:8166
_get_val_not_char                A:8072
_get_val_not_hex                 A:8065
_get_word_fail                   A:8086
_hex_nibble_digit                A:8171
_inc_insert_done                 A:8041
_lda_fail                        A:822F
_lda_not_immediate               A:821D
_print_done                      A:81A3
_print_loop                      A:8198
bad_handler                      A:80DF
dispatch                         A:80AA
dispatch_loop                    A:802A
end_msg                          A:81B8
err_msg                          A:81C9
get_byte                         A:8185
get_key                          A:8137
get_line                         A:80ED
get_nibble                       A:815B
get_val                          A:805A
get_word                         A:8075
hex_byte                         A:8174
hex_nibble                       A:8169
inc_insert                       A:803B
input_buf                        E:0200
input_ptr                        E:0010
insert_a                         A:8042
insert_ax                        A:804A
insert_ptr                       E:0030
jsr_handler                      A:8256
lda_handler                      A:820A
main                             A:8003
mainloop                         A:800E
opc_buf                          E:0020
opc_handler                      E:0023
opcode_table                     A:82A4
pha_handler                      A:828C
php_handler                      A:8292
pla_handler                      A:8298
plp_handler                      A:829E
print                            A:8194
print_addr                       A:8089
rts_handler                      A:8262
sta_handler                      A:8232
start_msg                        A:81A6
stx_handler                      A:823E
sty_handler                      A:824A
tax_handler                      A:8268
tay_handler                      A:826E
tsx_handler                      A:8280
txa_handler                      A:8274
txs_handler                      A:8286
tya_handler                      A:827A

Symbols by value:
0008 BACKSPACE
000A NEWLINE
0010 input_ptr
001B ESCAPE
0020 opc_buf
0023 opc_handler
0030 insert_ptr
0040 BYTE_BUILD
0050 PRINT
007F DELETE
0200 input_buf
8002 SERIAL
8003 main
800E mainloop
802A dispatch_loop
8038 _dispatch_loop_fail
803B inc_insert
8041 _inc_insert_done
8042 insert_a
804A insert_ax
805A get_val
8065 _get_val_not_hex
8072 _get_val_not_char
8075 get_word
8086 _get_word_fail
8089 print_addr
80AA dispatch
80D2 _dispatch_run
80D5 _dispatch_miss_3
80D6 _dispatch_miss_2
80D7 _dispatch_miss_1
80DF bad_handler
80ED get_line
80F1 _get_line_loop
8110 _get_line_done
8116 _get_line_backspace
8126 _get_line_backspace_ignore
8129 _get_line_escape
8137 get_key
8149 _get_key_new_addr
815B get_nibble
8166 _get_nibble_digit
8169 hex_nibble
8171 _hex_nibble_digit
8174 hex_byte
8185 get_byte
8194 print
8198 _print_loop
81A3 _print_done
81A6 start_msg
81B8 end_msg
81C9 err_msg
820A lda_handler
821D _lda_not_immediate
822F _lda_fail
8232 sta_handler
823E stx_handler
824A sty_handler
8256 jsr_handler
8262 rts_handler
8268 tax_handler
826E tay_handler
8274 txa_handler
827A tya_handler
8280 tsx_handler
8286 txs_handler
828C pha_handler
8292 php_handler
8298 pla_handler
829E plp_handler
82A4 opcode_table
FFF8 EXIT_VEC
