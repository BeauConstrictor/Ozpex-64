Sections:
00: "org0001:c003" (C003-C1AD)
01: "org0002:fff8" (FFF8-FFFA)
02: "org0003:fffc" (FFFC-FFFE)


Source: "programs/monitor.asm"
                        	     1:   .org $c003
                        	     2: 
                        	     3: ; memory map:
                        	     4: SERIAL   = $8002
                        	     5: EXIT_VEC = $fff8
                        	     6: 
                        	     7: ; ascii codes:
                        	     8: ESCAPE    = $1b
                        	     9: CLEAR     = $11
                        	    10: NEWLINE   = $0a
                        	    11: DELETE    = $7f
                        	    12: BACKSPACE = $08
                        	    13: 
                        	    14: ; memory allocation:
                        	    15: PRINT        = $50      ; 2 bytes
                        	    16: BYTE_BUILD   = $40      ; 1 byte
                        	    17: CURRENT_ADDR = $30      ; 2 bytes
                        	    18: RANGE_END    = $32      ; 2 bytes
                        	    19: 
                        	    20: reset:
00:C003 A97D            	    21:   lda #welcome_message
00:C005 8550            	    22:   sta PRINT
00:C007 A9C1            	    23:   lda #>welcome_message
00:C009 8551            	    24:   sta PRINT+1
00:C00B 206FC1          	    25:   jsr print
                        	    26: 
                        	    27:   ; if starting from the exit vector, skip the welcome message
                        	    28: restart:
00:C00E 2025C0          	    29:   jsr print_addr
                        	    30: 
                        	    31: loop:
                        	    32:   ; get a byte
00:C011 2060C1          	    33:   jsr get_byte
                        	    34: 
                        	    35:   ; write it to the address
00:C014 A000            	    36:   ldy #0
00:C016 9130            	    37:   sta (CURRENT_ADDR),y
                        	    38: 
00:C018 201EC0          	    39:   jsr next_addr
                        	    40: 
00:C01B 4C11C0          	    41:   jmp loop
                        	    42: 
                        	    43: ; increment the current memory address
                        	    44: ; modifies: 
                        	    45: next_addr:
00:C01E E630            	    46:   inc CURRENT_ADDR               ; increment low byte
00:C020 D002            	    47:   bne _next_addr_inc_didnt_carry ; if it didn’t overflow, we’re done
00:C022 E631            	    48:   inc CURRENT_ADDR+1             ; else, increment high byte
                        	    49: _next_addr_inc_didnt_carry:
00:C024 60              	    50:   rts
                        	    51: 
                        	    52: ; print the current memory address
                        	    53: ; modifies: a, x, y
                        	    54: print_addr:
                        	    55:   ; print the address
00:C025 A531            	    56:   lda CURRENT_ADDR+1
00:C027 204FC1          	    57:   jsr hex_byte
00:C02A 8E0280          	    58:   stx SERIAL
00:C02D 8C0280          	    59:   sty SERIAL
00:C030 A530            	    60:   lda CURRENT_ADDR
00:C032 204FC1          	    61:   jsr hex_byte
00:C035 8E0280          	    62:   stx SERIAL
00:C038 8C0280          	    63:   sty SERIAL
                        	    64: 
                        	    65:   ; print ': #
00:C03B A93A            	    66:   lda #":"
00:C03D 8D0280          	    67:   sta SERIAL
00:C040 A920            	    68:   lda #" "
00:C042 8D0280          	    69:   sta SERIAL
                        	    70: 
00:C045 60              	    71:   rts
                        	    72: 
                        	    73: ; return (in a) a single key, ignoring spaces
                        	    74: ; modifies: a, x, y
                        	    75: get_key:
00:C046 AD0280          	    76:   lda SERIAL
00:C049 F0FB            	    77:   beq get_key             ; if no char was typed, check again.
                        	    78: 
00:C04B C940            	    79:   cmp #"@"                ; if "@" was pressed,
00:C04D F026            	    80:   beq _get_key_new_addr   ; change address
                        	    81: 
00:C04F C921            	    82:   cmp #"!"                ; if shift+1 was pressed,
00:C051 F061            	    83:   beq _get_key_cs1        ; start cs1
00:C053 C922            	    84:   cmp #$22                ; if shift+2 was pressed,
00:C055 F063            	    85:   beq _get_key_cs2        ; start cs2
                        	    86: 
00:C057 C93E            	    87:   cmp #">"                ; if "." was pressed,
00:C059 F073            	    88:   beq _get_key_addr_range ; print an address range
                        	    89: 
00:C05B 8D0280          	    90:   sta SERIAL               ; echo back the char.
                        	    91: 
00:C05E C978            	    92:   cmp #"x"                ; if "x" was pressed,
00:C060 F05E            	    93:   beq _get_key_execute    ; execute a program
                        	    94: 
00:C062 C920            	    95:   cmp #" "                 ; if space was pressed,
00:C064 F0E0            	    96:   beq get_key              ; wait for the next key.
00:C066 C90A            	    97:   cmp #NEWLINE             ; if newline was pressed,
00:C068 F005            	    98:   beq _get_key_newline     ; handle it.
00:C06A C93B            	    99:   cmp #";"                 ; if space was pressed,
00:C06C F026            	   100:   beq _get_key_comment     ; start a comment.
                        	   101: 
00:C06E 60              	   102:   rts
                        	   103: _get_key_newline:
                        	   104:   ; show the latest memory address
00:C06F 2025C0          	   105:   jsr print_addr
00:C072 4C46C0          	   106:   jmp get_key
                        	   107: _get_key_new_addr:
00:C075 A90A            	   108:   lda #NEWLINE
00:C077 8D0280          	   109:   sta SERIAL
00:C07A 8D0280          	   110:   sta SERIAL
                        	   111: 
00:C07D 2060C1          	   112:   jsr get_byte
00:C080 8531            	   113:   sta CURRENT_ADDR+1
00:C082 2060C1          	   114:   jsr get_byte
00:C085 8530            	   115:   sta CURRENT_ADDR
                        	   116: 
00:C087 A93A            	   117:   lda #":"
00:C089 8D0280          	   118:   sta SERIAL
00:C08C A920            	   119:   lda #" "
00:C08E 8D0280          	   120:   sta SERIAL
                        	   121: 
00:C091 4C46C0          	   122:   jmp get_key
                        	   123: _get_key_comment:
00:C094 AD0280          	   124:   lda SERIAL                ; read a key.
00:C097 8D0280          	   125:   sta SERIAL
00:C09A C90A            	   126:   cmp #NEWLINE              ; only if it's a newline,
00:C09C F0D1            	   127:   beq _get_key_newline      ; exit the comment
                        	   128: 
00:C09E C97F            	   129:   cmp #DELETE               ; if they pressed backspace,
00:C0A0 D0F2            	   130:   bne _get_key_comment
00:C0A2 A908            	   131:   lda #BACKSPACE            ; move cursor back
00:C0A4 8D0280          	   132:   sta SERIAL
00:C0A7 A920            	   133:   lda #" "                  ; clear character
00:C0A9 8D0280          	   134:   sta SERIAL     
00:C0AC A908            	   135:   lda #BACKSPACE            ; move cursor back twice
00:C0AE 8D0280          	   136:   sta SERIAL
00:C0B1 4C94C0          	   137:   jmp _get_key_comment
                        	   138: _get_key_cs1:
00:C0B4 200380          	   139:   jsr $8003
00:C0B7 4C11C0          	   140:   jmp loop
                        	   141: _get_key_cs2:
00:C0BA 2003A0          	   142:   jsr $a003
00:C0BD 4C11C0          	   143:   jmp loop
                        	   144: _get_key_execute:
00:C0C0 A90A            	   145:   lda #NEWLINE
00:C0C2 8D0280          	   146:   sta SERIAL
00:C0C5 20CBC0          	   147:   jsr _get_key_execute_subroutine
00:C0C8 6CF8FF          	   148:   jmp (EXIT_VEC)
                        	   149: _get_key_execute_subroutine:
00:C0CB 6C3000          	   150:   jmp (CURRENT_ADDR)
                        	   151: _get_key_addr_range:
00:C0CE A9A2            	   152:   lda #addr_range_prompt
00:C0D0 8550            	   153:   sta PRINT
00:C0D2 A9C1            	   154:   lda #>addr_range_prompt
00:C0D4 8551            	   155:   sta PRINT+1
00:C0D6 206FC1          	   156:   jsr print
                        	   157: 
00:C0D9 2060C1          	   158:   jsr get_byte
00:C0DC 8533            	   159:   sta RANGE_END+1
00:C0DE 2060C1          	   160:   jsr get_byte
00:C0E1 8532            	   161:   sta RANGE_END
                        	   162: 
00:C0E3 A93A            	   163:   lda #":"
00:C0E5 8D0280          	   164:   sta SERIAL
00:C0E8 A90A            	   165:   lda #NEWLINE
00:C0EA 8D0280          	   166:   sta SERIAL
                        	   167: 
                        	   168:   ; skip the check for printing on $xxx0 addresses only
00:C0ED 2025C0          	   169:   jsr print_addr
00:C0F0 4C01C1          	   170:   jmp _get_key_addr_range_loop_skip_addr_print
                        	   171: 
                        	   172: _get_key_addr_range_loop:
                        	   173:   ; if the last nibble is 0, print the full address
00:C0F3 A530            	   174:   lda CURRENT_ADDR
00:C0F5 290F            	   175:   and #$0f
00:C0F7 D008            	   176:   bne _get_key_addr_range_loop_skip_addr_print
00:C0F9 A90A            	   177:   lda #NEWLINE
00:C0FB 8D0280          	   178:   sta SERIAL
00:C0FE 2025C0          	   179:   jsr print_addr
                        	   180: _get_key_addr_range_loop_skip_addr_print:
                        	   181: 
                        	   182:   ; output the byte
00:C101 A000            	   183:   ldy #0
00:C103 B130            	   184:   lda (CURRENT_ADDR),y
00:C105 204FC1          	   185:   jsr hex_byte
00:C108 8E0280          	   186:   stx SERIAL
00:C10B 8C0280          	   187:   sty SERIAL
00:C10E A920            	   188:   lda #" "
00:C110 8D0280          	   189:   sta SERIAL
                        	   190: 
                        	   191:   ; check if the low byte is at the end of the range
00:C113 A530            	   192:   lda CURRENT_ADDR
00:C115 C532            	   193:   cmp RANGE_END
00:C117 F006            	   194:   beq _get_key_addr_range_low_eq
                        	   195: 
                        	   196: _get_key_addr_range_inc:
00:C119 201EC0          	   197:   jsr next_addr
                        	   198: 
                        	   199:   ; loop again
00:C11C 4CF3C0          	   200:   jmp _get_key_addr_range_loop
                        	   201: 
                        	   202: _get_key_addr_range_low_eq:
                        	   203: ; then check if the high byte is at the end of the range
00:C11F A531            	   204:   lda CURRENT_ADDR+1
00:C121 C533            	   205:   cmp RANGE_END+1
                        	   206:   ; if so, finish printing the range
00:C123 F003            	   207:   beq _get_key_addr_range_high_eq
                        	   208:   ; else, increment and move on
00:C125 4C19C1          	   209:   jmp _get_key_addr_range_inc
                        	   210: 
                        	   211: _get_key_addr_range_high_eq:
00:C128 A90A            	   212:   lda #NEWLINE
00:C12A 8D0280          	   213:   sta SERIAL
00:C12D 8D0280          	   214:   sta SERIAL
00:C130 2025C0          	   215:   jsr print_addr
00:C133 4C11C0          	   216:   jmp loop
                        	   217: 
                        	   218: ; wait for a key and return (in a) the value of a single hex char
                        	   219: ; modifies: a (duh)
                        	   220: get_nibble:
00:C136 2046C0          	   221:   jsr get_key
00:C139 C93A            	   222:   cmp #$3a
00:C13B 9004            	   223:   bcc _get_nibble_digit
00:C13D 38              	   224:   sec
00:C13E E957            	   225:   sbc #"a" - 10
00:C140 60              	   226:   rts
                        	   227: _get_nibble_digit:
00:C141 E92F            	   228:   sbc #"0" - 1
00:C143 60              	   229:   rts
                        	   230: 
                        	   231: ; return (in a) the a register as hex
                        	   232: ; modifies: a (duh)
                        	   233: hex_nibble:
00:C144 C90A            	   234:   cmp #10
00:C146 9004            	   235:   bcc _hex_nibble_digit
00:C148 18              	   236:   clc
00:C149 6957            	   237:   adc #"a" - 10
00:C14B 60              	   238:   rts
                        	   239: _hex_nibble_digit:
00:C14C 6930            	   240:   adc #"0"
00:C14E 60              	   241:   rts
                        	   242: 
                        	   243: ; return (in x & y) the a register as hex
                        	   244: ; modifies: x, y, a
                        	   245: hex_byte:
00:C14F 48              	   246:   pha ; save the full value for later
                        	   247:   ; get just the MSN
00:C150 4A              	   248:   lsr
00:C151 4A              	   249:   lsr
00:C152 4A              	   250:   lsr
00:C153 4A              	   251:   lsr
00:C154 2044C1          	   252:   jsr hex_nibble
00:C157 AA              	   253:   tax ; but the hex char for the MSN in x
                        	   254: 
00:C158 68              	   255:   pla ; bring back the full value
00:C159 290F            	   256:   and #$0f ; get just the LSN
00:C15B 2044C1          	   257:   jsr hex_nibble
00:C15E A8              	   258:   tay ; but the hex char for the LSN in y
                        	   259: 
00:C15F 60              	   260:   rts
                        	   261: 
                        	   262: ; wait for a key and return (in a) the value of a byte (2 hex chars)
                        	   263: ; modifies: a (duh)
                        	   264: get_byte:
                        	   265:   ; get the MS nibble and move it to the MS area of the a reg
00:C160 2036C1          	   266:   jsr get_nibble
00:C163 0A              	   267:   asl
00:C164 0A              	   268:   asl
00:C165 0A              	   269:   asl
00:C166 0A              	   270:   asl
                        	   271:   ; move the MSN to memory
00:C167 8540            	   272:   sta BYTE_BUILD
                        	   273: 
                        	   274:   ; get the LSN and combine it with the MSN
00:C169 2036C1          	   275:   jsr get_nibble
00:C16C 0540            	   276:   ora BYTE_BUILD
00:C16E 60              	   277:   rts
                        	   278: 
                        	   279: ; print a null-terminated string pointed to by PRINT
                        	   280: ; modifies: a, y
                        	   281: print:
00:C16F A000            	   282:   ldy #0
                        	   283: _print_loop:
00:C171 B150            	   284:   lda (PRINT),y
00:C173 F007            	   285:   beq _print_done
00:C175 8D0280          	   286:   sta SERIAL
00:C178 C8              	   287:   iny
00:C179 4C71C1          	   288:   jmp _print_loop
                        	   289: _print_done:
00:C17C 60              	   290:   rts
                        	   291: 
                        	   292: welcome_message:
00:C17D 11              	   293:   .byte CLEAR
00:C17E 2A2A2A2A204F7A70	   294:   .byte "**** Ozpex 64 Monitor v2.0.0 ****", NEWLINE
00:C186 6578203634204D6F
00:C18E 6E69746F72207632
00:C196 2E302E30202A2A2A
00:C19E 2A
00:C19F 0A
                        	   295: 
00:C1A0 0A              	   296:   .byte NEWLINE, 0
00:C1A1 00
                        	   297: 
                        	   298: addr_range_prompt:
00:C1A2 08              	   299:   .byte BACKSPACE, BACKSPACE
00:C1A3 08
00:C1A4 2020            	   300:   .byte "  "
00:C1A6 08              	   301:   .byte BACKSPACE, BACKSPACE
00:C1A7 08
00:C1A8 202D3E20        	   302:   .byte " -> ", 0
00:C1AC 00
                        	   303: 
                        	   304:   .org EXIT_VEC
01:FFF8 0EC0            	   305:   .word restart
                        	   306: 
                        	   307: ; reset vector
                        	   308:   .org  $fffc
02:FFFC 03C0            	   309:   .word reset
                        	   310: 


Symbols by name:
BACKSPACE                        E:0008
BYTE_BUILD                       E:0040
CLEAR                            E:0011
CURRENT_ADDR                     E:0030
DELETE                           E:007F
EXIT_VEC                         E:FFF8
NEWLINE                          E:000A
PRINT                            E:0050
RANGE_END                        E:0032
SERIAL                           E:8002
_get_key_addr_range              A:C0CE
_get_key_addr_range_high_eq      A:C128
_get_key_addr_range_inc          A:C119
_get_key_addr_range_loop         A:C0F3
_get_key_addr_range_loop_skip_addr_print  A:C101
_get_key_addr_range_low_eq       A:C11F
_get_key_comment                 A:C094
_get_key_cs1                     A:C0B4
_get_key_cs2                     A:C0BA
_get_key_execute                 A:C0C0
_get_key_execute_subroutine      A:C0CB
_get_key_new_addr                A:C075
_get_key_newline                 A:C06F
_get_nibble_digit                A:C141
_hex_nibble_digit                A:C14C
_next_addr_inc_didnt_carry       A:C024
_print_done                      A:C17C
_print_loop                      A:C171
addr_range_prompt                A:C1A2
get_byte                         A:C160
get_key                          A:C046
get_nibble                       A:C136
hex_byte                         A:C14F
hex_nibble                       A:C144
loop                             A:C011
next_addr                        A:C01E
print                            A:C16F
print_addr                       A:C025
reset                            A:C003
restart                          A:C00E
welcome_message                  A:C17D

Symbols by value:
0008 BACKSPACE
000A NEWLINE
0011 CLEAR
0030 CURRENT_ADDR
0032 RANGE_END
0040 BYTE_BUILD
0050 PRINT
007F DELETE
8002 SERIAL
C003 reset
C00E restart
C011 loop
C01E next_addr
C024 _next_addr_inc_didnt_carry
C025 print_addr
C046 get_key
C06F _get_key_newline
C075 _get_key_new_addr
C094 _get_key_comment
C0B4 _get_key_cs1
C0BA _get_key_cs2
C0C0 _get_key_execute
C0CB _get_key_execute_subroutine
C0CE _get_key_addr_range
C0F3 _get_key_addr_range_loop
C101 _get_key_addr_range_loop_skip_addr_print
C119 _get_key_addr_range_inc
C11F _get_key_addr_range_low_eq
C128 _get_key_addr_range_high_eq
C136 get_nibble
C141 _get_nibble_digit
C144 hex_nibble
C14C _hex_nibble_digit
C14F hex_byte
C160 get_byte
C16F print
C171 _print_loop
C17C _print_done
C17D welcome_message
C1A2 addr_range_prompt
FFF8 EXIT_VEC
